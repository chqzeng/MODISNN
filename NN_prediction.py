import numpy as np
from collections import namedtuple

def Load_NNparams(param_file):
    """
    this function is used to load a simple NN model generated/trained from NN in matlab
    the network from Matlab is generated using : net=fitnet(hidden_node);
    the net is then trained and export as a csv file: struct2csv(NN_exporter(net),'test_NN_params.csv')
    where input of this function: param_file:  should be in the same format as "test_NN_params.csv"
    """
    #param_file=r'D:\VboxShare\Inter_Sensor\test_NN_params.csv'
    params=np.genfromtxt(param_file,dtype=float,delimiter=',',names=True)

    input_ymax=params['input_ymax'];
    input_ymax=input_ymax[np.logical_not(np.isnan(input_ymax))].tolist()
    input_ymin=params['input_ymin'];
    input_ymin=input_ymin[np.logical_not(np.isnan(input_ymin))].tolist()
    input_xmax=params['input_xmax'];
    input_xmax=input_xmax[np.logical_not(np.isnan(input_xmax))].tolist()
    input_xmin=params['input_xmin'];
    input_xmin=input_xmin[np.logical_not(np.isnan(input_xmin))].tolist()

    output_ymax=params['output_ymax'];
    output_ymax=output_ymax[np.logical_not(np.isnan(output_ymax))].tolist()
    output_ymin=params['output_ymin'];
    output_ymin=output_ymin[np.logical_not(np.isnan(output_ymin))].tolist()
    output_xmax=params['output_xmax'];
    output_xmax=output_xmax[np.logical_not(np.isnan(output_xmax))].tolist()
    output_xmin=params['output_xmin'];
    output_xmin=output_xmin[np.logical_not(np.isnan(output_xmin))].tolist()

    b1=params['b1'];
    b1=b1[np.logical_not(np.isnan(b1))].tolist()
    b2=params['b2'];
    b2=b2[np.logical_not(np.isnan(b2))].tolist()

    #IW-------------------------b1
    ##col={name: i for i,name in enumerate(params.dtype.names)}
    #param_data=params.view(np.float).reshape(params.shape+(-1,))
    param_data=params.view((float,len(params.dtype.names)))
    idx=params.dtype.names.index("IW")
    idy=params.dtype.names.index("b1")
    IW=param_data[:,idx:idy]
    IW=IW[~np.any(np.isnan(IW),axis=1)]  #remove nan values

    #LW-------------------------b2
    idx=params.dtype.names.index("LW")
    idy=params.dtype.names.index("b2")
    LW=param_data[:,idx:idy]
    LW=LW[~np.any(np.isnan(LW),axis=1)]  #remove nan values

    NNparams=namedtuple("NN_param_struct",'LW IW b1 b2 input_ymax input_ymin input_xmax input_xmin output_ymax output_ymin output_xmax output_xmin ')
    return NNparams(LW,IW,b1,b2,input_ymax, input_ymin, input_xmax, input_xmin, output_ymax, output_ymin, output_xmax, output_xmin)

def NN_prediction(nn_struct,input_val):
    """
    this function is used to predict value using a given trained Network.
    the network is loaded from Matalb trained result, as csv file, see Load_NNparams function for more details
    input:
        nn_struct: the structure file generated by the Load_NNparams function, including all params of a Matlab NN network
        input_val: the input of the network for the prediction, should be same "dimension/width" as trained;
                   size (K x N)  where K rows is # of samples, N columns are the dimension of NN input
    output:
        the result predicted output from NN: (M x K); where M rows are dimension of NN output, K is the # samples.
    """
    #NOW DO THE processsing
    #input_val=[0.0504890903830528,	0.0599313005805016	,0.0675626695156097	,0.0750852450728416	,0.0910424366593361	,0.0934763550758362	,0.0933277085423470	,0.0543195456266403	,0.0464699678122997	,0.0442353151738644	,0.0232394598424435	,0.0191557649523020	,0.0147293638437986]

    #first need to normalized the input data before enter NN
    ymax = nn_struct.input_ymax;
    ymin = nn_struct.input_ymin;
    xmax = nn_struct.input_xmax;
    xmin = nn_struct.input_xmin;
##    if ymax==1 and ymin==0 and xmax==1 and xmin==0:  #no scale needed
##        preprocessed=input_val
##    else:
    k=len(input_val);  #number of input samples
    offset=np.subtract(input_val,np.tile(xmin,(k,1)))
    scale=np.divide(offset,np.tile(np.subtract(xmax,xmin),(k,1)))
    #scale=np.divide(np.subtract(input_val,xmin),np.subtract(xmax,xmin))
    preprocessed=np.add(np.multiply(scale, np.subtract(ymax,ymin) ) , ymin)

    #NOW Rrun the NN and give the output
    ymax = nn_struct.output_ymax;
    ymin = nn_struct.output_ymin;
    xmax = nn_struct.output_xmax;
    xmin = nn_struct.output_xmin;
    y1 = np.tanh( np.add( nn_struct.IW.dot(np.transpose(preprocessed)) , np.transpose(np.tile(nn_struct.b1,(k,1)))))
    y2 = np.add(nn_struct.LW.dot(y1) ,np.transpose(np.tile(nn_struct.b2,(k,1))));
##    if ymax==1 and ymin==0 and xmax==1 and xmin==0:  #no scale needed
##        rst=y2
##    else:
    scale=np.divide(np.subtract(xmax,xmin), np.subtract(ymax,ymin))
    rst= np.add ( np.multiply( np.subtract(y2,ymin), np.transpose(np.tile(scale,(k,1)))), np.transpose(np.tile(xmin,(k,1))))
    return rst